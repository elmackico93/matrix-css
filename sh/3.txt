# MATRIX.CSS NEXT.JS FRAMEWORK - CONSOLIDATED FILE (PART 3/5)
# LAYOUT AND EFFECT COMPONENTS

===== src/components/layout/Col.tsx =====
import React, { HTMLAttributes, forwardRef } from 'react';
import { VariantProps, cva } from 'class-variance-authority';
import { cn } from '@/utils/cn';

const colVariants = cva(
  'px-[calc(var(--m-gap)/2)] mb-[var(--m-gap)]',
  {
    variants: {
      xs: {
        '1': 'w-[8.333333%]',
        '2': 'w-[16.666667%]',
        '3': 'w-[25%]',
        '4': 'w-[33.333333%]',
        '5': 'w-[41.666667%]',
        '6': 'w-[50%]',
        '7': 'w-[58.333333%]',
        '8': 'w-[66.666667%]',
        '9': 'w-[75%]',
        '10': 'w-[83.333333%]',
        '11': 'w-[91.666667%]',
        '12': 'w-[100%]',
        auto: 'w-auto',
      },
      sm: {
        '1': 'sm:w-[8.333333%]',
        '2': 'sm:w-[16.666667%]',
        '3': 'sm:w-[25%]',
        '4': 'sm:w-[33.333333%]',
        '5': 'sm:w-[41.666667%]',
        '6': 'sm:w-[50%]',
        '7': 'sm:w-[58.333333%]',
        '8': 'sm:w-[66.666667%]',
        '9': 'sm:w-[75%]',
        '10': 'sm:w-[83.333333%]',
        '11': 'sm:w-[91.666667%]',
        '12': 'sm:w-[100%]',
        auto: 'sm:w-auto',
      },
      md: {
        '1': 'md:w-[8.333333%]',
        '2': 'md:w-[16.666667%]',
        '3': 'md:w-[25%]',
        '4': 'md:w-[33.333333%]',
        '5': 'md:w-[41.666667%]',
        '6': 'md:w-[50%]',
        '7': 'md:w-[58.333333%]',
        '8': 'md:w-[66.666667%]',
        '9': 'md:w-[75%]',
        '10': 'md:w-[83.333333%]',
        '11': 'md:w-[91.666667%]',
        '12': 'md:w-[100%]',
        auto: 'md:w-auto',
      },
      lg: {
        '1': 'lg:w-[8.333333%]',
        '2': 'lg:w-[16.666667%]',
        '3': 'lg:w-[25%]',
        '4': 'lg:w-[33.333333%]',
        '5': 'lg:w-[41.666667%]',
        '6': 'lg:w-[50%]',
        '7': 'lg:w-[58.333333%]',
        '8': 'lg:w-[66.666667%]',
        '9': 'lg:w-[75%]',
        '10': 'lg:w-[83.333333%]',
        '11': 'lg:w-[91.666667%]',
        '12': 'lg:w-[100%]',
        auto: 'lg:w-auto',
      },
      xl: {
        '1': 'xl:w-[8.333333%]',
        '2': 'xl:w-[16.666667%]',
        '3': 'xl:w-[25%]',
        '4': 'xl:w-[33.333333%]',
        '5': 'xl:w-[41.666667%]',
        '6': 'xl:w-[50%]',
        '7': 'xl:w-[58.333333%]',
        '8': 'xl:w-[66.666667%]',
        '9': 'xl:w-[75%]',
        '10': 'xl:w-[83.333333%]',
        '11': 'xl:w-[91.666667%]',
        '12': 'xl:w-[100%]',
        auto: 'xl:w-auto',
      },
    },
    defaultVariants: {
      xs: '12',
    },
  }
);

export interface ColProps
  extends HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof colVariants> {}

const Col = forwardRef<HTMLDivElement, ColProps>(
  ({ className, xs, sm, md, lg, xl, ...props }, ref) => {
    return (
      <div
        ref={ref}
        className={cn(colVariants({ xs, sm, md, lg, xl }), className)}
        {...props}
      />
    );
  }
);

Col.displayName = 'Col';

export { Col };

===== src/components/layout/Container.tsx =====
import React, { HTMLAttributes, forwardRef } from 'react';
import { cn } from '@/utils/cn';

export interface ContainerProps extends HTMLAttributes<HTMLDivElement> {
  fluid?: boolean;
}

const Container = forwardRef<HTMLDivElement, ContainerProps>(
  ({ className, fluid = false, ...props }, ref) => {
    return (
      <div
        ref={ref}
        className={cn(
          'mx-auto px-4',
          fluid ? 'w-full' : 'max-w-[var(--m-container-width)]',
          className
        )}
        {...props}
      />
    );
  }
);

Container.displayName = 'Container';

export { Container };

===== src/components/layout/Footer.tsx =====
import React, { HTMLAttributes, forwardRef } from 'react';
import { cn } from '@/utils/cn';
import { Container } from './Container';

export interface FooterProps extends HTMLAttributes<HTMLElement> {
  bordered?: boolean;
  containerFluid?: boolean;
}

const Footer = forwardRef<HTMLElement, FooterProps>(
  ({ className, children, bordered = true, containerFluid = false, ...props }, ref) => {
    return (
      <footer
        ref={ref}
        className={cn(
          'bg-matrix-panel py-6',
          bordered && 'border-t border-matrix-border',
          className
        )}
        {...props}
      >
        <Container fluid={containerFluid}>{children}</Container>
      </footer>
    );
  }
);

Footer.displayName = 'Footer';

export { Footer };

===== src/components/layout/Row.tsx =====
import React, { HTMLAttributes, forwardRef } from 'react';
import { cn } from '@/utils/cn';

export interface RowProps extends HTMLAttributes<HTMLDivElement> {
  noGutters?: boolean;
}

const Row = forwardRef<HTMLDivElement, RowProps>(
  ({ className, noGutters = false, ...props }, ref) => {
    return (
      <div
        ref={ref}
        className={cn(
          'flex flex-wrap',
          noGutters
            ? 'mx-0'
            : 'mx-[calc(var(--m-gap)/-2)]',
          className
        )}
        {...props}
      />
    );
  }
);

Row.displayName = 'Row';

export { Row };

===== src/components/effects/CodeRain.tsx =====
import React, { useEffect, useRef, useState } from 'react';
import { cn } from '@/utils/cn';

export interface CodeRainProps {
  className?: string;
  density?: 'low' | 'medium' | 'high';
  speed?: 'slow' | 'medium' | 'fast';
  charSet?: 'default' | 'matrix' | 'binary' | 'custom';
  customChars?: string;
  glitchEffect?: boolean;
  backgroundColor?: string;
  textColor?: string;
  height?: string;
}

export const CodeRain: React.FC<CodeRainProps> = ({
  className,
  density = 'medium',
  speed = 'medium',
  charSet = 'default',
  customChars = '',
  glitchEffect = true,
  backgroundColor = 'var(--m-bg)',
  textColor = 'var(--m-text)',
  height = '100%',
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });
  const animationRef = useRef<number | null>(null);

  // Get the character set based on the prop
  const getCharacters = () => {
    switch (charSet) {
      case 'matrix':
        return 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$+-*/=%"\'#&_(),.;:?!\\|{}<>[]^~';
      case 'binary':
        return '01';
      case 'custom':
        return customChars || 'abcdefghijklmnopqrstuvwxyz0123456789';
      default:
        return 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$+-*/=%"\'#&_(),.;:?!\\|{}<>[]^~';
    }
  };

  // Get density value
  const getDensityValue = () => {
    switch (density) {
      case 'low':
        return 0.01;
      case 'high':
        return 0.03;
      default: // medium
        return 0.02;
    }
  };

  // Get speed value
  const getSpeedValue = () => {
    switch (speed) {
      case 'slow':
        return 1;
      case 'fast':
        return 3;
      default: // medium
        return 2;
    }
  };

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const updateDimensions = () => {
      const { offsetWidth, offsetHeight } = canvas.parentElement || { offsetWidth: 0, offsetHeight: 0 };
      setDimensions({ width: offsetWidth, height: offsetHeight });
      canvas.width = offsetWidth;
      canvas.height = offsetHeight;
    };

    updateDimensions();
    window.addEventListener('resize', updateDimensions);

    return () => {
      window.removeEventListener('resize', updateDimensions);
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, []);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas || dimensions.width === 0 || dimensions.height === 0) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const characters = getCharacters();
    const densityValue = getDensityValue();
    const speedValue = getSpeedValue();

    // Column properties
    const fontSize = 16;
    const columns = Math.floor(dimensions.width / fontSize);
    const drops: number[] = Array(columns).fill(1);

    // Frame rate control
    let lastTime = 0;
    const framesPerSecond = 30;
    const frameInterval = 1000 / framesPerSecond;

    const draw = (timestamp: number) => {
      // Calculate elapsed time
      const elapsed = timestamp - lastTime;

      // If enough time has passed, draw the next frame
      if (elapsed > frameInterval) {
        lastTime = timestamp - (elapsed % frameInterval);

        // Semi-transparent black background to show trail effect
        ctx.fillStyle = backgroundColor;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Set green text
        ctx.fillStyle = textColor;
        ctx.font = `${fontSize}px courier`;

        // Loop over each column
        for (let i = 0; i < drops.length; i++) {
          // Generate a random character from our set
          const text = characters.charAt(Math.floor(Math.random() * characters.length));

          // Randomize brightness for glitch effect if enabled
          if (glitchEffect && Math.random() > 0.95) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; // Bright white for glitch effect
          } else {
            ctx.fillStyle = textColor;
          }

          // Draw the character
          ctx.fillText(text, i * fontSize, drops[i] * fontSize);

          // Randomly reset some columns to top
          if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
            drops[i] = 0;
          }

          // Increment y coordinate for next character
          drops[i] += speedValue;
        }
      }

      animationRef.current = requestAnimationFrame(draw);
    };

    // Initialize additional raindrop streams based on density
    for (let i = 0; i < Math.floor(columns * densityValue); i++) {
      const randomColumn = Math.floor(Math.random() * columns);
      drops[randomColumn] = Math.floor(Math.random() * (canvas.height / fontSize));
    }

    // Start animation
    animationRef.current = requestAnimationFrame(draw);

    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [dimensions, density, speed, charSet, customChars, glitchEffect, backgroundColor, textColor]);

  return (
    <div
      className={cn('relative overflow-hidden', className)}
      style={{ height }}
    >
      <canvas
        ref={canvasRef}
        className="absolute inset-0"
      />
    </div>
  );
};

export default CodeRain;

===== src/components/effects/GlitchText.tsx =====
import React, { ElementType, ComponentPropsWithoutRef } from 'react';
import { cn } from '@/utils/cn';

type GlitchTextProps<T extends ElementType> = {
  text: string;
  intensity?: 'light' | 'medium' | 'heavy';
  as?: T;
} & ComponentPropsWithoutRef<T>;

export const GlitchText = <T extends ElementType = 'div'>({
  text,
  intensity = 'medium',
  as,
  className,
  ...props
}: GlitchTextProps<T>) => {
  const Component = as || 'div';

  // Set different animation values based on intensity
  const getIntensityStyles = () => {
    switch (intensity) {
      case 'light':
        return {
          beforeAnimation: 'animate-[glitch-1-light_2s_infinite_linear_alternate-reverse]',
          afterAnimation: 'animate-[glitch-2-light_3s_infinite_linear_alternate-reverse]',
        };
      case 'heavy':
        return {
          beforeAnimation: 'animate-[glitch-1-heavy_1.5s_infinite_linear_alternate-reverse]',
          afterAnimation: 'animate-[glitch-2-heavy_2s_infinite_linear_alternate-reverse]',
        };
      default: // medium
        return {
          beforeAnimation: 'animate-[glitch-1_2s_infinite_linear_alternate-reverse]',
          afterAnimation: 'animate-[glitch-2_3s_infinite_linear_alternate-reverse]',
        };
    }
  };

  const { beforeAnimation, afterAnimation } = getIntensityStyles();

  return (
    <Component
      data-text={text}
      className={cn(
        'relative text-matrix-text font-matrix tracking-wide',
        'before:content-[attr(data-text)] before:absolute before:top-0 before:left-0 before:w-full before:h-full before:bg-matrix-bg before:left-[2px] before:text-shadow-[hsl(0,100%,50%)_-2px_0] before:clip-path-[polygon(0_0,100%_0,100%_45%,0_45%)]',
        'after:content-[attr(data-text)] after:absolute after:top-0 after:left-0 after:w-full after:h-full after:bg-matrix-bg after:left-[-2px] after:text-shadow-[#00f_2px_0] after:clip-path-[polygon(0_55%,100%_55%,100%_100%,0_100%)]',
        beforeAnimation,
        afterAnimation,
        className
      )}
      {...props}
    >
      {text}
    </Component>
  );
};

export default GlitchText;

===== src/components/effects/NeuralNetwork.tsx =====
import React, { useEffect, useRef, useState } from 'react';
import { cn } from '@/utils/cn';

export interface NeuralNetworkProps {
  className?: string;
  height?: string;
  width?: string;
  layers?: number[];
  animated?: boolean;
  showLabels?: boolean;
  theme?: 'matrix' | 'blue' | 'purple';
}

interface Node {
  x: number;
  y: number;
  active: boolean;
}

interface Connection {
  from: Node;
  to: Node;
  active: boolean;
}

export const NeuralNetwork: React.FC<NeuralNetworkProps> = ({
  className,
  height = '300px',
  width = '100%',
  layers = [4, 6, 5, 3],
  animated = true,
  showLabels = true,
  theme = 'matrix',
}) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const [nodes, setNodes] = useState<Node[][]>([]);
  const [connections, setConnections] = useState<Connection[]>([]);
  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });
  
  // Get theme colors
  const getThemeColors = () => {
    switch (theme) {
      case 'blue':
        return {
          nodeColor: '#0066ff',
          activeNodeColor: '#00aaff',
          connectionColor: 'rgba(0, 102, 255, 0.3)',
          activeConnectionColor: '#0066ff',
          glow: 'rgba(0, 102, 255, 0.6)',
          textColor: '#0099ff'
        };
      case 'purple':
        return {
          nodeColor: '#aa00ff',
          activeNodeColor: '#cc00ff',
          connectionColor: 'rgba(170, 0, 255, 0.3)',
          activeConnectionColor: '#aa00ff',
          glow: 'rgba(170, 0, 255, 0.6)',
          textColor: '#cc33ff'
        };
      default: // matrix
        return {
          nodeColor: 'var(--m-text)',
          activeNodeColor: 'var(--m-text-bright)',
          connectionColor: 'var(--m-text-dim)',
          activeConnectionColor: 'var(--m-text)',
          glow: 'var(--m-glow)',
          textColor: 'var(--m-text)'
        };
    }
  };

  // Initialize network
  useEffect(() => {
    if (!containerRef.current) return;
    
    const updateDimensions = () => {
      if (containerRef.current) {
        const { clientWidth, clientHeight } = containerRef.current;
        setDimensions({ width: clientWidth, height: clientHeight });
      }
    };
    
    updateDimensions();
    window.addEventListener('resize', updateDimensions);
    
    return () => {
      window.removeEventListener('resize', updateDimensions);
    };
  }, []);

  // Generate nodes and connections when dimensions change
  useEffect(() => {
    if (dimensions.width === 0 || dimensions.height === 0) return;
    
    const newNodes: Node[][] = [];
    const newConnections: Connection[] = [];
    
    // Generate nodes for each layer
    const layerGap = dimensions.width / (layers.length + 1);
    
    layers.forEach((nodeCount, layerIndex) => {
      const layerX = layerGap * (layerIndex + 1);
      const layerNodes: Node[] = [];
      
      // Calculate vertical spacing
      const nodeGap = dimensions.height / (nodeCount + 1);
      
      for (let i = 0; i < nodeCount; i++) {
        const nodeY = nodeGap * (i + 1);
        layerNodes.push({
          x: layerX,
          y: nodeY,
          active: false
        });
      }
      
      newNodes.push(layerNodes);
    });
    
    // Generate connections between layers
    for (let i = 0; i < newNodes.length - 1; i++) {
      const currentLayer = newNodes[i];
      const nextLayer = newNodes[i + 1];
      
      // Connect each node to all nodes in the next layer
      currentLayer.forEach(fromNode => {
        nextLayer.forEach(toNode => {
          newConnections.push({
            from: fromNode,
            to: toNode,
            active: false
          });
        });
      });
    }
    
    setNodes(newNodes);
    setConnections(newConnections);
  }, [dimensions, layers]);

  // Animation function
  useEffect(() => {
    if (!animated || nodes.length === 0) return;
    
    const activationInterval = setInterval(() => {
      // Randomly activate input nodes
      setNodes(prevNodes => {
        const newNodes = [...prevNodes];
        const inputLayer = [...newNodes[0]];
        
        // Reset all nodes
        newNodes.forEach(layer => {
          layer.forEach(node => {
            node.active = false;
          });
        });
        
        // Activate a random input node
        const randomNodeIndex = Math.floor(Math.random() * inputLayer.length);
        inputLayer[randomNodeIndex].active = true;
        newNodes[0] = inputLayer;
        
        return newNodes;
      });
      
      // Update connections based on active nodes
      setConnections(prevConnections => {
        return prevConnections.map(conn => ({
          ...conn,
          active: conn.from.active && Math.random() > 0.5
        }));
      });
      
      // After a delay, activate nodes in the next layer based on connections
      setTimeout(() => {
        setNodes(prevNodes => {
          const newNodes = [...prevNodes];
          
          // Activate nodes if they have an active incoming connection
          for (let i = 1; i < newNodes.length; i++) {
            newNodes[i] = newNodes[i].map(node => ({
              ...node,
              active: connections.some(conn => conn.to === node && conn.active)
            }));
          }
          
          return newNodes;
        });
      }, 150);
      
    }, 2000);
    
    return () => clearInterval(activationInterval);
  }, [animated, nodes, connections]);
  
  const themeColors = getThemeColors();

  return (
    <div
      ref={containerRef}
      className={cn(
        'relative bg-matrix-bg border border-matrix-border rounded overflow-hidden',
        className
      )}
      style={{ height, width }}
    >
      {/* Radial gradient background effect */}
      <div 
        className="absolute inset-0 bg-radial-gradient"
        style={{
          background: `radial-gradient(circle at 50% 50%, ${themeColors.glow} 0%, transparent 70%)`
        }}
      />
      
      {/* Render connections */}
      <svg className="absolute inset-0 w-full h-full">
        {connections.map((conn, i) => (
          <line
            key={`conn-${i}`}
            x1={conn.from.x}
            y1={conn.from.y}
            x2={conn.to.x}
            y2={conn.to.y}
            stroke={conn.active ? themeColors.activeConnectionColor : themeColors.connectionColor}
            strokeWidth={conn.active ? 2 : 1}
            style={{
              transition: 'stroke 0.3s',
              boxShadow: conn.active ? `0 0 5px ${themeColors.glow}` : 'none'
            }}
          />
        ))}
      </svg>
      
      {/* Render layers */}
      {nodes.map((layer, layerIndex) => (
        <div
          key={`layer-${layerIndex}`}
          className="absolute h-full"
          style={{ left: `${(layerIndex + 1) * 100 / (layers.length + 1)}%`, transform: 'translateX(-50%)' }}
        >
          {/* Layer label */}
          {showLabels && (
            <div 
              className="absolute top-2 text-center w-full text-xs font-matrix-hacker" 
              style={{ color: themeColors.textColor }}
            >
              {layerIndex === 0 ? 'Input' : layerIndex === layers.length - 1 ? 'Output' : `Hidden ${layerIndex}`}
            </div>
          )}
          
          {/* Render nodes */}
          {layer.map((node, nodeIndex) => (
            <div
              key={`node-${layerIndex}-${nodeIndex}`}
              className={cn(
                'absolute w-5 h-5 rounded-full border-2 transform -translate-x-1/2 -translate-y-1/2',
                node.active && 'animate-[neuron-pulse_2s_infinite]'
              )}
              style={{
                left: 0,
                top: node.y,
                backgroundColor: node.active ? themeColors.activeNodeColor : 'transparent',
                borderColor: node.active ? themeColors.activeNodeColor : themeColors.nodeColor,
                boxShadow: node.active ? `0 0 10px ${themeColors.glow}` : 'none',
                transition: 'background-color 0.3s, border-color 0.3s, box-shadow 0.3s'
              }}
            />
          ))}
        </div>
      ))}
    </div>
  );
};

export default NeuralNetwork;

===== src/components/effects/Scanline.tsx =====
import React, { HTMLAttributes } from 'react';
import { cn } from '@/utils/cn';

export interface ScanlineProps extends HTMLAttributes<HTMLDivElement> {
  intensity?: 'light' | 'medium' | 'heavy';
  type?: 'horizontal' | 'vertical' | 'both';
  children: React.ReactNode;
}

export const Scanline: React.FC<ScanlineProps> = ({
  intensity = 'medium',
  type = 'horizontal',
  children,
  className,
  ...props
}) => {
  // Get CSS variables based on intensity
  const getIntensityStyles = () => {
    switch (intensity) {
      case 'light':
        return {
          opacity: '0.3',
          size: '1px',
          gap: '10px',
        };
      case 'heavy':
        return {
          opacity: '0.7',
          size: '3px',
          gap: '8px',
        };
      default: // medium
        return {
          opacity: '0.5',
          size: '2px',
          gap: '9px',
        };
    }
  };

  const { opacity, size, gap } = getIntensityStyles();

  const horizontalScanline = type === 'horizontal' || type === 'both';
  const verticalScanline = type === 'vertical' || type === 'both';

  return (
    <div
      className={cn(
        'relative overflow-hidden',
        className
      )}
      {...props}
    >
      {/* Original content */}
      {children}

      {/* Horizontal scanlines */}
      {horizontalScanline && (
        <div
          className="pointer-events-none absolute inset-0 z-10"
          style={{
            backgroundImage: `linear-gradient(
              to bottom,
              transparent ${gap},
              rgba(0, 0, 0, ${opacity}) ${gap},
              rgba(0, 0, 0, ${opacity}) calc(${gap} + ${size}),
              transparent calc(${gap} + ${size})
            )`,
            backgroundSize: `100% calc(${gap} + ${size})`,
            backgroundRepeat: 'repeat',
          }}
        />
      )}

      {/* Vertical scanlines */}
      {verticalScanline && (
        <div
          className="pointer-events-none absolute inset-0 z-10"
          style={{
            backgroundImage: `linear-gradient(
              to right,
              transparent ${gap},
              rgba(0, 0, 0, ${opacity}) ${gap},
              rgba(0, 0, 0, ${opacity}) calc(${gap} + ${size}),
              transparent calc(${gap} + ${size})
            )`,
            backgroundSize: `calc(${gap} + ${size}) 100%`,
            backgroundRepeat: 'repeat',
          }}
        />
      )}

      {/* Moving scanline effect */}
      {horizontalScanline && (
        <div
          className="pointer-events-none absolute inset-0 z-20"
          style={{
            background: `linear-gradient(to bottom, transparent, transparent 50%, rgba(0, 255, 65, 0.1) 50%, transparent)`,
            backgroundSize: '100% 4px',
            animation: 'scanline 10s linear infinite',
          }}
        />
      )}
    </div>
  );
};

export default Scanline;

===== src/components/effects/Terminal.tsx =====
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { cn } from '@/utils/cn';

export interface TerminalProps {
  title?: string;
  prompt?: string;
  commands?: Record<string, (args: string[]) => string>;
  initialCommands?: string[];
  className?: string;
  height?: string;
  width?: string;
  allowUserInput?: boolean;
  readOnly?: boolean;
  showHeader?: boolean;
  autoFocus?: boolean;
  syntaxHighlighting?: boolean;
  typingEffect?: boolean;
  typingSpeed?: number;
  theme?: 'matrix' | 'dark' | 'light';
  fontSize?: string;
  fontFamily?: string;
  initialContent?: string;
  onCommand?: (command: string, output: string) => void;
}

export const Terminal: React.FC<TerminalProps> = ({
  title = 'Matrix Terminal',
  prompt = '>',
  commands = {},
  initialCommands = [],
  className,
  height = '400px',
  width = '100%',
  allowUserInput = true,
  readOnly = false,
  showHeader = true,
  autoFocus = false,
  syntaxHighlighting = true,
  typingEffect = false,
  typingSpeed = 50,
  theme = 'matrix',
  fontSize = '14px',
  fontFamily = 'var(--m-font-hacker)',
  initialContent = '',
  onCommand,
}) => {
  const [output, setOutput] = useState<string[]>(initialContent ? [initialContent] : []);
  const [currentInput, setCurrentInput] = useState('');
  const [history, setHistory] = useState<string[]>([]);
  const [historyIndex, setHistoryIndex] = useState(-1);
  const [isTyping, setIsTyping] = useState(false);
  const [typingText, setTypingText] = useState('');
  const [typingIndex, setTypingIndex] = useState(0);
  
  const inputRef = useRef<HTMLInputElement>(null);
  const outputRef = useRef<HTMLDivElement>(null);

  const defaultCommands = {
    help: () =>
      'Available commands: ' +
      Object.keys({
        ...defaultCommands,
        ...commands,
      }).join(', '),
    clear: () => {
      setOutput([]);
      return '';
    },
    echo: (args: string[]) => args.join(' '),
    date: () => new Date().toLocaleString(),
  };

  const allCommands = {
    ...defaultCommands,
    ...commands,
  };

  // Execute initial commands
  useEffect(() => {
    if (initialCommands.length > 0) {
      const executeInitialCommands = async () => {
        for (const cmd of initialCommands) {
          await executeCommand(cmd, true);
        }
      };
      executeInitialCommands();
    }
  }, []);

  // Scroll to bottom on new output
  useEffect(() => {
    if (outputRef.current) {
      outputRef.current.scrollTop = outputRef.current.scrollHeight;
    }
  }, [output]);

  // Typing effect logic
  useEffect(() => {
    if (isTyping && typingText && typingIndex < typingText.length) {
      const timer = setTimeout(() => {
        setTypingIndex(prev => prev + 1);
      }, typingSpeed);
      return () => clearTimeout(timer);
    } else if (isTyping && typingIndex >= typingText.length) {
      setIsTyping(false);
      setOutput(prev => [...prev, typingText]);
      setTypingText('');
      setTypingIndex(0);
    }
  }, [isTyping, typingText, typingIndex, typingSpeed]);

  const typeOutput = async (text: string): Promise<void> => {
    if (typingEffect) {
      return new Promise((resolve) => {
        setTypingText(text);
        setTypingIndex(0);
        setIsTyping(true);
        
        // Set up a timer to resolve the promise after typing is complete
        const checkTypingComplete = setInterval(() => {
          if (!isTyping) {
            clearInterval(checkTypingComplete);
            resolve();
          }
        }, 100);
      });
    } else {
      // No typing effect, just add to output immediately
      setOutput(prev => [...prev, text]);
      return Promise.resolve();
    }
  };

  const executeCommand = async (input: string, isInitial = false): Promise<void> => {
    // Add command to output
    if (!isInitial || (isInitial && !typingEffect)) {
      setOutput(prev => [...prev, `${prompt} ${input}`]);
    } else if (isInitial && typingEffect) {
      await typeOutput(`${prompt} ${input}`);
    }

    // Process command
    const args = input.trim().split(' ');
    const command = args[0].toLowerCase();
    const commandArgs = args.slice(1);
    
    let result = '';

    if (command === '') {
      // Do nothing for empty command
    } else if (command in allCommands) {
      try {
        result = allCommands[command](commandArgs);
        if (result) {
          if (typingEffect) {
            await typeOutput(result);
          } else {
            setOutput(prev => [...prev, result]);
          }
        }
      } catch (error) {
        const errorMessage = `Error executing command: ${error}`;
        setOutput(prev => [...prev, errorMessage]);
        result = errorMessage;
      }
    } else {
      const notFoundMessage = `Command not found: ${command}. Type 'help' for available commands.`;
      setOutput(prev => [...prev, notFoundMessage]);
      result = notFoundMessage;
    }

    // Add to history if not empty and not an initial command
    if (input.trim() && !isInitial) {
      setHistory(prev => [input, ...prev].slice(0, 50)); // Keep last 50 commands
    }

    // Call onCommand callback if provided
    if (onCommand && !isInitial) {
      onCommand(input, result);
    }

    setCurrentInput('');
    setHistoryIndex(-1);
  };

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setCurrentInput(e.target.value);
  };

  const handleInputKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      executeCommand(currentInput);
    } else if (e.key === 'ArrowUp') {
      // Navigate command history (older)
      e.preventDefault();
      if (history.length > 0 && historyIndex < history.length - 1) {
        const newIndex = historyIndex + 1;
        setHistoryIndex(newIndex);
        setCurrentInput(history[newIndex]);
      }
    } else if (e.key === 'ArrowDown') {
      // Navigate command history (newer)
      e.preventDefault();
      if (historyIndex > 0) {
        const newIndex = historyIndex - 1;
        setHistoryIndex(newIndex);
        setCurrentInput(history[newIndex]);
      } else if (historyIndex === 0) {
        setHistoryIndex(-1);
        setCurrentInput('');
      }
    }
  };

  const focusInput = () => {
    if (allowUserInput && inputRef.current) {
      inputRef.current.focus();
    }
  };

  // Format output with syntax highlighting
  const formatOutput = (text: string): React.ReactNode => {
    if (!syntaxHighlighting) return text;
    
    // Basic syntax highlighting
    if (text.startsWith(prompt)) {
      // Command line
      const commandPart = text.substring(prompt.length).trim();
      return (
        <>
          <span className="text-matrix-text-dim">{prompt}</span>{' '}
          <span className="text-matrix-text-bright">{commandPart}</span>
        </>
      );
    } else if (text.startsWith('Error') || text.includes('not found')) {
      // Error messages
      return <span className="text-matrix-danger">{text}</span>;
    } else if (text.match(/^(Available commands:|Usage:)/)) {
      // Help text
      return <span className="text-matrix-info">{text}</span>;
    } else if (text.match(/^[0-9\-/: ]+$/)) {
      // Date/time
      return <span className="text-matrix-success">{text}</span>;
    } else {
      // Regular output
      return text;
    }
  };

  // Apply theme-specific styles
  const getThemeStyles = () => {
    switch (theme) {
      case 'dark':
        return {
          bg: 'bg-black',
          border: 'border-gray-800',
          text: 'text-gray-200',
          header: 'bg-gray-900',
        };
      case 'light':
        return {
          bg: 'bg-gray-100',
          border: 'border-gray-300',
          text: 'text-gray-800',
          header: 'bg-gray-200',
        };
      case 'matrix':
      default:
        return {
          bg: 'bg-[rgba(0,10,0,0.95)]',
          border: 'border-matrix-border',
          text: 'text-matrix-text',
          header: 'bg-[rgba(0,20,0,0.7)]',
        };
    }
  };
  
  const themeStyles = getThemeStyles();

  useEffect(() => {
    if (autoFocus) {
      focusInput();
    }
  }, [autoFocus]);

  return (
    <div
      className={cn(
        themeStyles.bg,
        themeStyles.border,
        'rounded overflow-hidden shadow-[0_0_20px_rgba(0,0,0,0.5),0_0_10px_var(--m-glow)]',
        className
      )}
      onClick={focusInput}
      style={{ height, width, fontFamily }}
    >
      {showHeader && (
        <div className={cn('flex justify-between items-center p-2 border-b', themeStyles.header, themeStyles.border)}>
          <div className={cn('text-sm font-bold tracking-wider', themeStyles.text)}>{title}</div>
          <div className="flex gap-1.5">
            <div className="w-3 h-3 rounded-full bg-[#FF5F56]"></div>
            <div className="w-3 h-3 rounded-full bg-[#FFBD2E]"></div>
            <div className="w-3 h-3 rounded-full bg-[#27C93F]"></div>
          </div>
        </div>
      )}

      <div className="p-4 h-full flex flex-col">
        <div
          ref={outputRef}
          className={cn('flex-1 overflow-y-auto mb-2 whitespace-pre-wrap', themeStyles.text)}
          style={{ fontSize }}
        >
          {output.map((line, i) => (
            <div key={i} className="mb-1 leading-tight">
              {formatOutput(line)}
            </div>
          ))}
          
          {/* Currently typing text with cursor */}
          {isTyping && (
            <div className="mb-1 leading-tight">
              {formatOutput(typingText.substring(0, typingIndex))}
              <span className="animate-[cursor-blink_1s_step-end_infinite] bg-matrix-text inline-block w-2 h-4 align-middle"></span>
            </div>
          )}
        </div>

        {allowUserInput && !readOnly && (
          <div className="flex items-center">
            <span className={cn('mr-2', theme === 'matrix' ? 'text-matrix-text-bright' : '')}>{prompt}</span>
            <input
              ref={inputRef}
              type="text"
              value={currentInput}
              onChange={handleInputChange}
              onKeyDown={handleInputKeyDown}
              className={cn(
                'flex-1 bg-transparent border-none outline-none focus:text-matrix-text-bright caret-[var(--m-text)]',
                themeStyles.text
              )}
              style={{ fontSize }}
              aria-label="Terminal input"
            />
            <span className={cn('w-2.5 h-5 bg-matrix-text animate-[cursor-blink_1s_step-end_infinite]', theme !== 'matrix' && 'bg-current')}></span>
          </div>
        )}
      </div>
    </div>
  );
};

export default Terminal;

===== src/components/effects/TerminalOverlay.tsx =====
import React, { useState, useEffect, useRef } from 'react';
import { cn } from '@/utils/cn';
import Terminal, { TerminalProps } from '@/components/effects/Terminal';

export interface TerminalOverlayProps {
  isOpen: boolean;
  onClose: () => void;
  title?: string;
  commands?: Record<string, (args: string[]) => string>;
  initialCommands?: string[];
  sourceElementId?: string; // ID of the element to animate from
  className?: string;
  overlayClassName?: string;
  terminalClassName?: string;
  showLoadingProgress?: boolean;
  loadingDuration?: number;
  maxWidth?: string;
  matrixEffects?: boolean;
  onComplete?: () => void;
  terminalProps?: Partial<TerminalProps>;
}

export const TerminalOverlay: React.FC<TerminalOverlayProps> = ({
  isOpen,
  onClose,
  title = 'MATRIX SYSTEM INITIALIZATION',
  commands = {},
  initialCommands = ['help'],
  sourceElementId,
  className,
  overlayClassName,
  terminalClassName,
  showLoadingProgress = true,
  loadingDuration = 3000, // 3 seconds loading by default
  maxWidth = '2xl',
  matrixEffects = true,
  onComplete,
  terminalProps = {},
}) => {
  const [isVisible, setIsVisible] = useState(false);
  const [loadingProgress, setLoadingProgress] = useState(0);
  const [isLoading, setIsLoading] = useState(true);
  const [isClosing, setIsClosing] = useState(false);
  const [sourcePosition, setSourcePosition] = useState<{ top: number; left: number; width: number; height: number } | null>(null);
  
  const overlayRef = useRef<HTMLDivElement>(null);
  const terminalRef = useRef<HTMLDivElement>(null);
  
  // Default terminal commands
  const defaultCommands = {
    help: () => 'Available commands: help, system, status, exit',
    system: () => 'Matrix System Online. Version 2.0.0',
    status: () => 'All systems operational. Connection secure.',
    exit: () => {
      handleClose();
      return 'Exiting system...';
    },
  };
  
  const allCommands = {
    ...defaultCommands,
    ...commands,
  };

  // Get position of source element for animation
  useEffect(() => {
    if (isOpen && sourceElementId) {
      const sourceElement = document.getElementById(sourceElementId);
      if (sourceElement) {
        const rect = sourceElement.getBoundingClientRect();
        setSourcePosition({
          top: rect.top,
          left: rect.left,
          width: rect.width,
          height: rect.height,
        });
      }
    }
  }, [isOpen, sourceElementId]);

  // Handle body scroll lock
  useEffect(() => {
    if (isOpen) {
      document.body.style.overflow = 'hidden';
      // Focus trap to be implemented here
    }
    return () => {
      document.body.style.overflow = '';
    };
  }, [isOpen]);
  
  // Animation timing
  useEffect(() => {
    if (isOpen) {
      // Start animation sequence
      setIsVisible(true);
      setIsLoading(true);
      setLoadingProgress(0);
      
      // Simulate loading progress
      let startTime = Date.now();
      const loadingInterval = setInterval(() => {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(Math.round((elapsed / loadingDuration) * 100), 100);
        
        setLoadingProgress(progress);
        
        if (progress >= 100) {
          clearInterval(loadingInterval);
          setIsLoading(false);
          
          if (onComplete) {
            onComplete();
          }
        }
      }, 50);
      
      return () => {
        clearInterval(loadingInterval);
      };
    }
  }, [isOpen, loadingDuration, onComplete]);
  
  // Handle escape key
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape' && isOpen) {
        handleClose();
      }
    };
    
    window.addEventListener('keydown', handleKeyDown);
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
    };
  }, [isOpen]);
  
  // Handle close with animation
  const handleClose = () => {
    setIsClosing(true);
    
    // Animation timing
    setTimeout(() => {
      setIsVisible(false);
      setIsClosing(false);
      onClose();
    }, 500);
  };
  
  // Classes based on maxWidth parameter
  const getMaxWidthClass = () => {
    const widthClasses: Record<string, string> = {
      sm: 'max-w-sm',
      md: 'max-w-md',
      lg: 'max-w-lg',
      xl: 'max-w-xl',
      '2xl': 'max-w-2xl',
      '3xl': 'max-w-3xl',
      '4xl': 'max-w-4xl',
      '5xl': 'max-w-5xl',
      full: 'max-w-full',
    };
    
    return widthClasses[maxWidth] || 'max-w-2xl';
  };
  
  if (!isOpen && !isVisible) {
    return null;
  }
  
  return (
    <div
      ref={overlayRef}
      className={cn(
        'fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-90 transition-all duration-500',
        isVisible ? 'opacity-100' : 'opacity-0',
        isClosing && 'animate-[fadeOut_0.5s_ease-in-out]',
        overlayClassName
      )}
      onClick={(e) => {
        // Close when clicking outside the terminal
        if (terminalRef.current && !terminalRef.current.contains(e.target as Node)) {
          handleClose();
        }
      }}
    >
      {/* Matrix effects overlay */}
      {matrixEffects && (
        <div className="absolute inset-0 overflow-hidden pointer-events-none">
          {/* Binary rain columns */}
          <div className="binary-rain-container">
            {Array.from({ length: 20 }).map((_, i) => (
              <div key={i} className="binary-column" style={{ 
                left: `${i * 5}%`, 
                animationDelay: `${Math.random() * 5}s`,
                animationDuration: `${5 + Math.random() * 10}s`
              }}>
                {Array.from({ length: 15 }).map((_, j) => (
                  <div key={j} className="binary-digit" style={{
                    animationDelay: `${Math.random() * 2}s`,
                    opacity: Math.random() < 0.7 ? 0.4 : 0.8
                  }}>
                    {Math.random() > 0.5 ? '1' : '0'}
                  </div>
                ))}
              </div>
            ))}
          </div>
          
          {/* Matrix system warnings */}
          <div className="absolute bottom-8 left-8 text-left">
            <div className="text-[var(--m-text)] font-mono text-xs mb-2 opacity-70">SYSTEM STATUS</div>
            <div className="system-warning">WARNING: Unauthorized access detected</div>
            <div className="system-warning">ALERT: Security protocol engaged</div>
            <div className="system-warning">NOTICE: Terminal mode active</div>
          </div>
          
          {/* Grid lines */}
          <div className="grid-overlay"></div>
        </div>
      )}
      
      {/* Terminal container - animated from source if specified */}
      <div
        ref={terminalRef}
        style={sourcePosition ? {
          // Start animation from source element position
          transform: isVisible ? 'scale(1)' : `scale(0.5) translate(
            ${sourcePosition.left - window.innerWidth/2 + sourcePosition.width/2}px, 
            ${sourcePosition.top - window.innerHeight/2 + sourcePosition.height/2}px
          )`,
        } : {}}
        className={cn(
          'w-full p-4 transition-all duration-500',
          getMaxWidthClass(),
          isVisible ? 'opacity-100 scale-100' : 'opacity-0 scale-90',
          className
        )}
      >
        <Terminal
          title={title}
          commands={allCommands}
          initialCommands={initialCommands}
          className={cn(terminalClassName)}
          height={showLoadingProgress ? "300px" : "400px"}
          allowUserInput={!isLoading}
          readOnly={isLoading}
          syntaxHighlighting={true}
          typingEffect={true}
          theme="matrix"
          {...terminalProps}
        />
        
        {/* Loading progress bar */}
        {showLoadingProgress && (
          <div className="mt-4">
            <div className="h-2 bg-black border border-matrix-border overflow-hidden">
              <div 
                className="h-full bg-matrix-text transition-all duration-300"
                style={{ width: `${loadingProgress}%` }}
              ></div>
            </div>
            <div className="text-right text-xs mt-1 text-matrix-text">
              {loadingProgress}% COMPLETE
            </div>
            
            {loadingProgress >= 100 && (
              <div className="text-center mt-4 animate-pulse">
                <span className="text-matrix-text-bright">INITIALIZATION COMPLETE - ENTERING THE MATRIX</span>
              </div>
            )}
          </div>
        )}

        {/* Cancel button */}
        <div className="text-center mt-6">
          <button 
            className="px-4 py-2 bg-black border border-matrix-border rounded text-matrix-text hover:text-matrix-text-bright hover:border-matrix-text transition-colors"
            onClick={handleClose}
          >
            CANCEL
          </button>
        </div>
      </div>
      
      {/* CSS for Matrix effects */}
      <style jsx global>{`
        .binary-column {
          position: absolute;
          top: -20%;
          display: flex;
          flex-direction: column;
          justify-content: center;
          align-items: center;
          animation: binary-fall linear infinite;
        }
        
        @keyframes binary-fall {
          0% { transform: translateY(0); }
          100% { transform: translateY(120vh); }
        }
        
        .binary-digit {
          color: var(--m-text);
          font-family: monospace;
          font-size: 14px;
          margin: 4px 0;
          animation: digit-flicker 3s infinite alternate;
        }
        
        @keyframes digit-flicker {
          0%, 100% { opacity: 0.3; }
          50% { opacity: 0.8; }
        }
        
        .system-warning {
          font-family: monospace;
          color: var(--m-text);
          font-size: 12px;
          margin-bottom: 6px;
          text-transform: uppercase;
          letter-spacing: 1px;
          animation: warning-blink 4s infinite;
          opacity: 0.8;
        }
        
        @keyframes warning-blink {
          0%, 92%, 96%, 100% { opacity: 0.8; }
          94%, 98% { opacity: 1; }
        }
        
        .grid-overlay {
          position: absolute;
          inset: 0;
          background-image: 
            radial-gradient(rgba(0, 255, 65, 0.3) 1px, transparent 1px);
          background-size: 40px 40px;
          pointer-events: none;
          opacity: 0.2;
        }
        
        @keyframes fadeOut {
          from { opacity: 1; }
          to { opacity: 0; }
        }
      `}</style>
    </div>
  );
};

export default TerminalOverlay;